<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DirectionalScanLiftController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Lift Simulator</a> &gt; <a href="index.source.html" class="el_package">com.liftsimulator.engine</a> &gt; <span class="el_source">DirectionalScanLiftController.java</span></div><h1>DirectionalScanLiftController.java</h1><pre class="source lang-java linenums">package com.liftsimulator.engine;

import com.liftsimulator.domain.Action;
import com.liftsimulator.domain.CarCall;
import com.liftsimulator.domain.Direction;
import com.liftsimulator.domain.DoorState;
import com.liftsimulator.domain.HallCall;
import com.liftsimulator.domain.IdleParkingMode;
import com.liftsimulator.domain.LiftRequest;
import com.liftsimulator.domain.LiftState;
import com.liftsimulator.domain.LiftStatus;
import com.liftsimulator.domain.RequestState;
import com.liftsimulator.domain.RequestType;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;

/**
 * Implements a directional scan controller.
 * The controller maintains travel direction and services all requests in that direction
 * before reversing (or idling if none).
 */
public final class DirectionalScanLiftController implements RequestManagingLiftController {
    private static final int DEFAULT_HOME_FLOOR = 0;
    private static final int DEFAULT_IDLE_TIMEOUT_TICKS = 5;
<span class="nc" id="L32">    private static final IdleParkingMode DEFAULT_IDLE_PARKING_MODE = IdleParkingMode.PARK_TO_HOME_FLOOR;</span>

<span class="nc" id="L34">    private final Map&lt;Long, LiftRequest&gt; requestsById = new HashMap&lt;&gt;();</span>
<span class="nc" id="L35">    private final Set&lt;LiftRequest&gt; activeRequests = new HashSet&lt;&gt;();</span>
<span class="nc" id="L36">    private final Set&lt;LiftRequest&gt; completedRequests = new HashSet&lt;&gt;();</span>
    private final int homeFloor;
    private final int idleTimeoutTicks;
    private final IdleParkingMode idleParkingMode;
    private Long idleStartTick;
    private boolean parkingInProgress;
    private boolean outOfService;
<span class="nc" id="L43">    private Direction currentDirection = Direction.IDLE;</span>

    public DirectionalScanLiftController() {
<span class="nc" id="L46">        this(DEFAULT_HOME_FLOOR, DEFAULT_IDLE_TIMEOUT_TICKS, DEFAULT_IDLE_PARKING_MODE);</span>
<span class="nc" id="L47">    }</span>

    public DirectionalScanLiftController(int homeFloor, int idleTimeoutTicks) {
<span class="nc" id="L50">        this(homeFloor, idleTimeoutTicks, DEFAULT_IDLE_PARKING_MODE);</span>
<span class="nc" id="L51">    }</span>

<span class="nc" id="L53">    public DirectionalScanLiftController(int homeFloor, int idleTimeoutTicks, IdleParkingMode idleParkingMode) {</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">        if (idleTimeoutTicks &lt; 0) {</span>
<span class="nc" id="L55">            throw new IllegalArgumentException(&quot;idleTimeoutTicks must be &gt;= 0&quot;);</span>
        }
<span class="nc bnc" id="L57" title="All 2 branches missed.">        if (idleParkingMode == null) {</span>
<span class="nc" id="L58">            throw new IllegalArgumentException(&quot;idleParkingMode must not be null&quot;);</span>
        }
<span class="nc" id="L60">        this.homeFloor = homeFloor;</span>
<span class="nc" id="L61">        this.idleTimeoutTicks = idleTimeoutTicks;</span>
<span class="nc" id="L62">        this.idleParkingMode = idleParkingMode;</span>
<span class="nc" id="L63">    }</span>

    /**
     * Adds a car call (destination request from inside the lift).
     *
     * @param carCall the car call to add
     */
    public void addCarCall(CarCall carCall) {
<span class="nc bnc" id="L71" title="All 2 branches missed.">        if (outOfService) {</span>
<span class="nc" id="L72">            return;</span>
        }
<span class="nc" id="L74">        LiftRequest request = LiftRequest.carCall(carCall.destinationFloor());</span>
<span class="nc" id="L75">        request.transitionTo(RequestState.QUEUED);</span>
<span class="nc" id="L76">        trackRequest(request);</span>
<span class="nc" id="L77">    }</span>

    /**
     * Adds a hall call (request from a floor to go up or down).
     *
     * @param hallCall the hall call to add
     */
    public void addHallCall(HallCall hallCall) {
<span class="nc bnc" id="L85" title="All 2 branches missed.">        if (outOfService) {</span>
<span class="nc" id="L86">            return;</span>
        }
<span class="nc" id="L88">        LiftRequest request = LiftRequest.hallCall(hallCall.floor(), hallCall.direction());</span>
<span class="nc" id="L89">        request.transitionTo(RequestState.QUEUED);</span>
<span class="nc" id="L90">        trackRequest(request);</span>
<span class="nc" id="L91">    }</span>

    /**
     * Adds a lift request directly.
     *
     * @param request the lift request to add
     */
    public void addRequest(LiftRequest request) {
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (outOfService) {</span>
<span class="nc" id="L100">            return;</span>
        }
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (request.getState() == RequestState.CREATED) {</span>
<span class="nc" id="L103">            request.transitionTo(RequestState.QUEUED);</span>
        }
<span class="nc" id="L105">        trackRequest(request);</span>
<span class="nc" id="L106">    }</span>

    /**
     * Cancels a lift request by its ID.
     * The request will be transitioned to CANCELLED state and removed from the queue.
     * This method is safe to call for requests in any state.
     *
     * @param requestId the ID of the request to cancel
     * @return true if the request was found and cancelled, false if not found or already terminal
     */
    public boolean cancelRequest(long requestId) {
<span class="nc" id="L117">        LiftRequest request = requestsById.get(requestId);</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (request == null) {</span>
<span class="nc" id="L119">            return false;</span>
        }

        // If already terminal (completed or cancelled), nothing to do.
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (request.isTerminal()) {</span>
<span class="nc" id="L124">            return false;</span>
        }

        // Transition to cancelled state.
<span class="nc" id="L128">        request.transitionTo(RequestState.CANCELLED);</span>

<span class="nc" id="L130">        archiveRequest(request);</span>

<span class="nc" id="L132">        return true;</span>
    }

    /**
     * Completes all requests for the given floor.
     * This is called when the lift arrives at a floor and opens doors.
     * Transitions requests from SERVING to COMPLETED.
     *
     * @param floor the floor to complete requests for
     */
    private void completeRequestsForFloor(int floor, Direction direction) {
<span class="nc" id="L143">        Set&lt;LiftRequest&gt; requestsToComplete = activeRequests.stream()</span>
<span class="nc bnc" id="L144" title="All 4 branches missed.">                .filter(request -&gt; !request.isTerminal() &amp;&amp; request.getTargetFloor() == floor)</span>
<span class="nc" id="L145">                .filter(request -&gt; isEligibleForDirection(request, direction))</span>
<span class="nc" id="L146">                .collect(Collectors.toSet());</span>

<span class="nc bnc" id="L148" title="All 2 branches missed.">        for (LiftRequest request : requestsToComplete) {</span>
<span class="nc" id="L149">            request.completeRequest();</span>
<span class="nc" id="L150">        }</span>

        // Remove completed requests.
<span class="nc bnc" id="L153" title="All 2 branches missed.">        for (LiftRequest request : requestsToComplete) {</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">            if (request.isTerminal()) {</span>
<span class="nc" id="L155">                archiveRequest(request);</span>
            }
<span class="nc" id="L157">        }</span>
<span class="nc" id="L158">    }</span>

    /**
     * Checks if there is any active request for the given floor.
     *
     * @param floor the floor to check
     * @return true if there is an active request for this floor
     */
    private boolean hasRequestForFloor(int floor, Direction direction) {
<span class="nc" id="L167">        return activeRequests.stream()</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">                .filter(request -&gt; !request.isTerminal())</span>
<span class="nc" id="L169">                .filter(request -&gt; isEligibleForDirection(request, direction))</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">                .anyMatch(request -&gt; request.getTargetFloor() == floor);</span>
    }

    /**
     * Gets all active (non-terminal) requests.
     *
     * @return set of active requests
     */
    private Set&lt;LiftRequest&gt; getActiveRequests() {
<span class="nc" id="L179">        return Collections.unmodifiableSet(activeRequests);</span>
    }

    private boolean hasRequestsInDirection(int currentFloor, Direction direction) {
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (direction == Direction.IDLE) {</span>
<span class="nc" id="L184">            return false;</span>
        }
<span class="nc" id="L186">        return getActiveRequests().stream()</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">                .filter(request -&gt; !request.isTerminal())</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">                .anyMatch(request -&gt; direction == Direction.UP</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                        ? request.getTargetFloor() &gt; currentFloor</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">                        : request.getTargetFloor() &lt; currentFloor);</span>
    }

    /**
     * Finds the nearest floor with a pending request.
     * Assigns requests to the lift when they are selected for service.
     *
     * @param currentFloor the current floor of the lift
     * @return the nearest requested floor, or empty if no requests
     */
    private Optional&lt;Integer&gt; findNearestRequestedFloor(int currentFloor) {
<span class="nc" id="L201">        Set&lt;Integer&gt; requestedFloors = new TreeSet&lt;&gt;();</span>

        // Collect all requested floors from active requests.
<span class="nc bnc" id="L204" title="All 2 branches missed.">        for (LiftRequest request : getActiveRequests()) {</span>
<span class="nc" id="L205">            requestedFloors.add(request.getTargetFloor());</span>
<span class="nc" id="L206">        }</span>

        // Find the nearest one.
<span class="nc" id="L209">        return requestedFloors.stream()</span>
<span class="nc" id="L210">                .min((f1, f2) -&gt; {</span>
<span class="nc" id="L211">                    int dist1 = Math.abs(f1 - currentFloor);</span>
<span class="nc" id="L212">                    int dist2 = Math.abs(f2 - currentFloor);</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">                    if (dist1 != dist2) {</span>
<span class="nc" id="L214">                        return Integer.compare(dist1, dist2);</span>
                    }
<span class="nc" id="L216">                    return Integer.compare(f1, f2);</span>
                });
    }

    private Optional&lt;Integer&gt; findNextRequestedFloorInDirection(int currentFloor, Direction direction) {
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (direction == Direction.IDLE) {</span>
<span class="nc" id="L222">            return Optional.empty();</span>
        }

<span class="nc" id="L225">        return getActiveRequests().stream()</span>
<span class="nc" id="L226">                .filter(request -&gt; isEligibleForDirection(request, direction))</span>
<span class="nc" id="L227">                .map(LiftRequest::getTargetFloor)</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">                .filter(targetFloor -&gt; direction == Direction.UP</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">                        ? targetFloor &gt; currentFloor</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">                        : targetFloor &lt; currentFloor)</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">                .sorted(direction == Direction.UP ? Integer::compareTo : (f1, f2) -&gt; Integer.compare(f2, f1))</span>
<span class="nc" id="L232">                .findFirst();</span>
    }

    private Optional&lt;Integer&gt; findTurnaroundFloorInDirection(int currentFloor, Direction direction) {
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (direction == Direction.IDLE) {</span>
<span class="nc" id="L237">            return Optional.empty();</span>
        }

<span class="nc" id="L240">        return getActiveRequests().stream()</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                .filter(request -&gt; !request.isTerminal())</span>
<span class="nc" id="L242">                .map(LiftRequest::getTargetFloor)</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">                .filter(targetFloor -&gt; direction == Direction.UP</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">                        ? targetFloor &gt; currentFloor</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                        : targetFloor &lt; currentFloor)</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                .reduce((floor1, floor2) -&gt; direction == Direction.UP</span>
<span class="nc" id="L247">                        ? Math.max(floor1, floor2)</span>
<span class="nc" id="L248">                        : Math.min(floor1, floor2));</span>
    }

    private boolean shouldReverseAtCurrentFloor(int currentFloor) {
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (currentDirection == Direction.IDLE) {</span>
<span class="nc" id="L253">            return false;</span>
        }
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (findTurnaroundFloorInDirection(currentFloor, currentDirection).isPresent()) {</span>
<span class="nc" id="L256">            return false;</span>
        }
<span class="nc bnc" id="L258" title="All 2 branches missed.">        Direction oppositeDirection = currentDirection == Direction.UP ? Direction.DOWN : Direction.UP;</span>
<span class="nc" id="L259">        return hasRequestForFloor(currentFloor, oppositeDirection);</span>
    }

    /**
     * Assigns requests for the target floor to the lift.
     * Changes state from QUEUED to ASSIGNED.
     *
     * @param targetFloor floor that lift will go to.
     */
    private void assignRequestsForFloor(int targetFloor, Direction direction) {
<span class="nc" id="L269">        activeRequests.stream()</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">                .filter(request -&gt; request.getTargetFloor() == targetFloor)</span>
<span class="nc" id="L271">                .filter(request -&gt; isEligibleForDirection(request, direction))</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">                .filter(request -&gt; request.getState() == RequestState.QUEUED)</span>
<span class="nc" id="L273">                .forEach(request -&gt; request.transitionTo(RequestState.ASSIGNED));</span>
<span class="nc" id="L274">    }</span>

    /**
     * Marks assigned requests for the target floor as SERVING.
     *
     * @param targetFloor floor that lift is now serving.
     */
    private void serveRequestsForFloor(int targetFloor, Direction direction) {
<span class="nc" id="L282">        activeRequests.stream()</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">                .filter(request -&gt; request.getTargetFloor() == targetFloor)</span>
<span class="nc" id="L284">                .filter(request -&gt; isEligibleForDirection(request, direction))</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">                .filter(request -&gt; request.getState() == RequestState.ASSIGNED)</span>
<span class="nc" id="L286">                .forEach(request -&gt; request.transitionTo(RequestState.SERVING));</span>
<span class="nc" id="L287">    }</span>

    private void resetIdleTracking() {
<span class="nc" id="L290">        idleStartTick = null;</span>
<span class="nc" id="L291">        parkingInProgress = false;</span>
<span class="nc" id="L292">    }</span>

    private boolean shouldTrackIdle(LiftState currentState) {
<span class="nc bnc" id="L295" title="All 4 branches missed.">        return currentState.getStatus() == LiftStatus.IDLE &amp;&amp; currentState.getDoorState() == DoorState.CLOSED;</span>
    }

    private Action moveTowardHome(int currentFloor) {
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (currentFloor &lt; homeFloor) {</span>
<span class="nc" id="L300">            return Action.MOVE_UP;</span>
        }
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (currentFloor &gt; homeFloor) {</span>
<span class="nc" id="L303">            return Action.MOVE_DOWN;</span>
        }
<span class="nc" id="L305">        return Action.IDLE;</span>
    }

    private Action handleIdleParking(LiftState currentState, long currentTick) {
<span class="nc" id="L309">        int currentFloor = currentState.getFloor();</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        if (parkingInProgress) {</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">            if (currentFloor == homeFloor) {</span>
<span class="nc" id="L312">                parkingInProgress = false;</span>
<span class="nc" id="L313">                idleStartTick = currentTick;</span>
<span class="nc" id="L314">                return Action.IDLE;</span>
            }
<span class="nc" id="L316">            return moveTowardHome(currentFloor);</span>
        }

<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (shouldTrackIdle(currentState)) {</span>
<span class="nc" id="L320">            Long trackedIdleStartTick = idleStartTick;</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">            if (trackedIdleStartTick == null) {</span>
<span class="nc" id="L322">                trackedIdleStartTick = currentTick;</span>
<span class="nc" id="L323">                idleStartTick = currentTick;</span>
            }
<span class="nc" id="L325">            long idleTicks = currentTick - trackedIdleStartTick;</span>
<span class="nc bnc" id="L326" title="All 6 branches missed.">            if (idleTicks &gt;= idleTimeoutTicks &amp;&amp; currentFloor != homeFloor</span>
                    &amp;&amp; idleParkingMode == IdleParkingMode.PARK_TO_HOME_FLOOR) {
<span class="nc" id="L328">                parkingInProgress = true;</span>
<span class="nc" id="L329">                return moveTowardHome(currentFloor);</span>
            }
<span class="nc" id="L331">        } else {</span>
<span class="nc" id="L332">            idleStartTick = null;</span>
        }
<span class="nc" id="L334">        return Action.IDLE;</span>
    }

    private boolean isEligibleForDirection(LiftRequest request, Direction direction) {
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (direction == Direction.IDLE) {</span>
<span class="nc" id="L339">            return true;</span>
        }
<span class="nc bnc" id="L341" title="All 2 branches missed.">        if (request.getType() == RequestType.HALL_CALL) {</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">            return request.getDirection() == direction;</span>
        }
<span class="nc" id="L344">        return true;</span>
    }

    @Override
    public Action decideNextAction(LiftState currentState, long currentTick) {
<span class="nc" id="L349">        int currentFloor = currentState.getFloor();</span>
<span class="nc" id="L350">        DoorState doorState = currentState.getDoorState();</span>
<span class="nc" id="L351">        LiftStatus currentStatus = currentState.getStatus();</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">        boolean hasActiveRequests = !getActiveRequests().isEmpty();</span>

<span class="nc bnc" id="L354" title="All 4 branches missed.">        if (currentStatus == LiftStatus.OUT_OF_SERVICE || outOfService) {</span>
<span class="nc" id="L355">            return Action.IDLE;</span>
        }

<span class="nc bnc" id="L358" title="All 2 branches missed.">        if (hasActiveRequests) {</span>
<span class="nc" id="L359">            resetIdleTracking();</span>
        }

        // Allow door transitions to complete before evaluating movement.
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (currentStatus == LiftStatus.DOORS_OPENING) {</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">            if (hasRequestForFloor(currentFloor, currentDirection)) {</span>
<span class="nc" id="L365">                serveRequestsForFloor(currentFloor, currentDirection);</span>
<span class="nc" id="L366">                completeRequestsForFloor(currentFloor, currentDirection);</span>
            }
<span class="nc" id="L368">            return Action.IDLE;</span>
        }

<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (currentStatus == LiftStatus.DOORS_CLOSING) {</span>
            // Check if a new request arrived for current floor while doors closing.
<span class="nc bnc" id="L373" title="All 2 branches missed.">            if (hasRequestForFloor(currentFloor, currentDirection)) {</span>
                // Attempt to reopen doors (will succeed only if within reopen window).
<span class="nc" id="L375">                return Action.OPEN_DOOR;</span>
            }
<span class="nc" id="L377">            return Action.IDLE;</span>
        }

        // If doors are open, let the engine manage the dwell/close cycle.
<span class="nc bnc" id="L381" title="All 2 branches missed.">        if (doorState == DoorState.OPEN) {</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">            if (hasRequestForFloor(currentFloor, currentDirection)) {</span>
<span class="nc" id="L383">                completeRequestsForFloor(currentFloor, currentDirection);</span>
            }
<span class="nc" id="L385">            return Action.IDLE;</span>
        }

<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (shouldReverseAtCurrentFloor(currentFloor)) {</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">            currentDirection = currentDirection == Direction.UP ? Direction.DOWN : Direction.UP;</span>
        }

        // If at a requested floor, stop first if moving, then open doors.
<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (hasRequestForFloor(currentFloor, currentDirection)) {</span>
<span class="nc bnc" id="L394" title="All 4 branches missed.">            if (currentStatus == LiftStatus.MOVING_UP || currentStatus == LiftStatus.MOVING_DOWN) {</span>
<span class="nc" id="L395">                assignRequestsForFloor(currentFloor, currentDirection);</span>
<span class="nc" id="L396">                serveRequestsForFloor(currentFloor, currentDirection);</span>
<span class="nc" id="L397">                return Action.IDLE;</span>
            }
<span class="nc bnc" id="L399" title="All 2 branches missed.">            if (currentStatus == LiftStatus.DOORS_OPENING) {</span>
<span class="nc" id="L400">                completeRequestsForFloor(currentFloor, currentDirection);</span>
<span class="nc" id="L401">                return Action.IDLE;</span>
            }
<span class="nc" id="L403">            assignRequestsForFloor(currentFloor, currentDirection);</span>
<span class="nc" id="L404">            serveRequestsForFloor(currentFloor, currentDirection);</span>
<span class="nc" id="L405">            return Action.OPEN_DOOR;</span>
        }

<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (!hasActiveRequests) {</span>
<span class="nc" id="L409">            currentDirection = Direction.IDLE;</span>
<span class="nc" id="L410">            return handleIdleParking(currentState, currentTick);</span>
        }

<span class="nc bnc" id="L413" title="All 2 branches missed.">        if (currentDirection == Direction.IDLE) {</span>
<span class="nc" id="L414">            Optional&lt;Integer&gt; nearestFloor = findNearestRequestedFloor(currentFloor);</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">            if (nearestFloor.isPresent()) {</span>
<span class="nc" id="L416">                int targetFloor = nearestFloor.get();</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">                currentDirection = targetFloor &gt; currentFloor ? Direction.UP : Direction.DOWN;</span>
            }
        }

<span class="nc" id="L421">        Optional&lt;Integer&gt; turnaroundFloor = findTurnaroundFloorInDirection(currentFloor, currentDirection);</span>
<span class="nc" id="L422">        Optional&lt;Integer&gt; nextFloor = findNextRequestedFloorInDirection(currentFloor, currentDirection);</span>
<span class="nc bnc" id="L423" title="All 4 branches missed.">        if (nextFloor.isEmpty() &amp;&amp; turnaroundFloor.isPresent()) {</span>
<span class="nc" id="L424">            nextFloor = turnaroundFloor;</span>
        }
<span class="nc bnc" id="L426" title="All 2 branches missed.">        if (nextFloor.isEmpty()) {</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">            Direction oppositeDirection = currentDirection == Direction.UP ? Direction.DOWN : Direction.UP;</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">            if (hasRequestsInDirection(currentFloor, oppositeDirection)) {</span>
<span class="nc" id="L429">                currentDirection = oppositeDirection;</span>
<span class="nc" id="L430">                turnaroundFloor = findTurnaroundFloorInDirection(currentFloor, currentDirection);</span>
<span class="nc" id="L431">                nextFloor = findNextRequestedFloorInDirection(currentFloor, currentDirection);</span>
<span class="nc bnc" id="L432" title="All 4 branches missed.">                if (nextFloor.isEmpty() &amp;&amp; turnaroundFloor.isPresent()) {</span>
<span class="nc" id="L433">                    nextFloor = turnaroundFloor;</span>
                }
            } else {
<span class="nc" id="L436">                currentDirection = Direction.IDLE;</span>
<span class="nc" id="L437">                return handleIdleParking(currentState, currentTick);</span>
            }
        }

<span class="nc" id="L441">        int targetFloor = nextFloor.orElse(currentFloor);</span>
<span class="nc" id="L442">        assignRequestsForFloor(targetFloor, currentDirection);</span>

<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (currentDirection == Direction.UP) {</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">            if (currentStatus == LiftStatus.MOVING_DOWN) {</span>
<span class="nc" id="L446">                return Action.IDLE;</span>
            }
<span class="nc bnc" id="L448" title="All 2 branches missed.">            return currentFloor &lt; targetFloor ? Action.MOVE_UP : Action.IDLE;</span>
        }

<span class="nc bnc" id="L451" title="All 2 branches missed.">        if (currentStatus == LiftStatus.MOVING_UP) {</span>
<span class="nc" id="L452">            return Action.IDLE;</span>
        }
<span class="nc bnc" id="L454" title="All 2 branches missed.">        return currentFloor &gt; targetFloor ? Action.MOVE_DOWN : Action.IDLE;</span>
    }

    /**
     * Takes the lift out of service by cancelling all active requests.
     * This method cancels all non-terminal requests (QUEUED, ASSIGNED, SERVING).
     * After calling this method, the lift should be transitioned to OUT_OF_SERVICE
     * state via the SimulationEngine.
     *
     * The lift will:
     * - Stop at the nearest floor if moving
     * - Open and close doors if at a floor
     * - Cancel all pending requests
     */
    public void takeOutOfService() {
<span class="nc" id="L469">        outOfService = true;</span>
        // Cancel all active (non-terminal) requests.
<span class="nc" id="L471">        Set&lt;LiftRequest&gt; activeRequests = new HashSet&lt;&gt;(getActiveRequests());</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">        for (LiftRequest request : activeRequests) {</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">            if (!request.isTerminal()) {</span>
<span class="nc" id="L474">                request.transitionTo(RequestState.CANCELLED);</span>
<span class="nc" id="L475">                archiveRequest(request);</span>
            }
<span class="nc" id="L477">        }</span>

        // Reset idle tracking and parking state.
<span class="nc" id="L480">        resetIdleTracking();</span>
<span class="nc" id="L481">        currentDirection = Direction.IDLE;</span>
<span class="nc" id="L482">    }</span>

    /**
     * Prepares the lift to return to service.
     * After calling this method, the lift should be transitioned from OUT_OF_SERVICE
     * to IDLE state via the SimulationEngine.
     */
    public void returnToService() {
<span class="nc" id="L490">        outOfService = false;</span>
        // Reset idle tracking when returning to service.
<span class="nc" id="L492">        resetIdleTracking();</span>
<span class="nc" id="L493">        currentDirection = Direction.IDLE;</span>
<span class="nc" id="L494">    }</span>

    /**
     * Gets all requests (for testing purposes).
     *
     * @return a copy of all requests
     */
    public Set&lt;LiftRequest&gt; getRequests() {
<span class="nc" id="L502">        return new HashSet&lt;&gt;(activeRequests);</span>
    }

    private void archiveRequest(LiftRequest request) {
<span class="nc" id="L506">        activeRequests.remove(request);</span>
<span class="nc" id="L507">        completedRequests.add(request);</span>
<span class="nc" id="L508">        requestsById.remove(request.getId());</span>
<span class="nc" id="L509">    }</span>

    private void trackRequest(LiftRequest request) {
<span class="nc" id="L512">        activeRequests.add(request);</span>
<span class="nc" id="L513">        requestsById.put(request.getId(), request);</span>
<span class="nc" id="L514">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>