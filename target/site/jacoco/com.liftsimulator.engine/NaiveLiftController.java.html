<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NaiveLiftController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Lift Simulator</a> &gt; <a href="index.source.html" class="el_package">com.liftsimulator.engine</a> &gt; <span class="el_source">NaiveLiftController.java</span></div><h1>NaiveLiftController.java</h1><pre class="source lang-java linenums">package com.liftsimulator.engine;

import com.liftsimulator.domain.Action;
import com.liftsimulator.domain.CarCall;
import com.liftsimulator.domain.DoorState;
import com.liftsimulator.domain.HallCall;
import com.liftsimulator.domain.IdleParkingMode;
import com.liftsimulator.domain.LiftRequest;
import com.liftsimulator.domain.LiftState;
import com.liftsimulator.domain.LiftStatus;
import com.liftsimulator.domain.RequestState;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;

/**
 * A naive lift controller that implements basic scheduling logic.
 * This controller manages lift requests as first-class entities with
 * explicit lifecycle states, servicing requests by moving to the nearest requested floor.
 *
 * Decision rules:
 * - When the lift reaches a requested floor, open the doors
 * - When doors are open and dwell time has elapsed, close the doors
 * - Otherwise, move toward the nearest floor with a pending request
 *
 * Request lifecycle:
 * - CREATED: Request is created
 * - QUEUED: Request is added to the controller's queue
 * - ASSIGNED: Request is assigned to the lift for service
 * - SERVING: Lift is actively serving the request
 * - COMPLETED: Request has been successfully fulfilled
 * - CANCELLED: Request was cancelled before completion
 *
 * Optimization is out of scope; this focuses on correctness first.
 */
public final class NaiveLiftController implements RequestManagingLiftController {
    private static final int DEFAULT_HOME_FLOOR = 0;
    private static final int DEFAULT_IDLE_TIMEOUT_TICKS = 5;
<span class="nc" id="L45">    private static final IdleParkingMode DEFAULT_IDLE_PARKING_MODE = IdleParkingMode.PARK_TO_HOME_FLOOR;</span>

<span class="nc" id="L47">    private final Map&lt;Long, LiftRequest&gt; requestsById = new HashMap&lt;&gt;();</span>
<span class="nc" id="L48">    private final Set&lt;LiftRequest&gt; activeRequests = new HashSet&lt;&gt;();</span>
<span class="nc" id="L49">    private final Set&lt;LiftRequest&gt; completedRequests = new HashSet&lt;&gt;();</span>
    private final int homeFloor;
    private final int idleTimeoutTicks;
    private final IdleParkingMode idleParkingMode;
    private Long idleStartTick;
    private boolean parkingInProgress;
    private boolean outOfService;

    public NaiveLiftController() {
<span class="nc" id="L58">        this(DEFAULT_HOME_FLOOR, DEFAULT_IDLE_TIMEOUT_TICKS, DEFAULT_IDLE_PARKING_MODE);</span>
<span class="nc" id="L59">    }</span>

    public NaiveLiftController(int homeFloor, int idleTimeoutTicks) {
<span class="nc" id="L62">        this(homeFloor, idleTimeoutTicks, DEFAULT_IDLE_PARKING_MODE);</span>
<span class="nc" id="L63">    }</span>

<span class="nc" id="L65">    public NaiveLiftController(int homeFloor, int idleTimeoutTicks, IdleParkingMode idleParkingMode) {</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">        if (idleTimeoutTicks &lt; 0) {</span>
<span class="nc" id="L67">            throw new IllegalArgumentException(&quot;idleTimeoutTicks must be &gt;= 0&quot;);</span>
        }
<span class="nc bnc" id="L69" title="All 2 branches missed.">        if (idleParkingMode == null) {</span>
<span class="nc" id="L70">            throw new IllegalArgumentException(&quot;idleParkingMode must not be null&quot;);</span>
        }
<span class="nc" id="L72">        this.homeFloor = homeFloor;</span>
<span class="nc" id="L73">        this.idleTimeoutTicks = idleTimeoutTicks;</span>
<span class="nc" id="L74">        this.idleParkingMode = idleParkingMode;</span>
<span class="nc" id="L75">    }</span>

    /**
     * Adds a car call (destination request from inside the lift).
     *
     * @param carCall the car call to add
     */
    public void addCarCall(CarCall carCall) {
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (outOfService) {</span>
<span class="nc" id="L84">            return;</span>
        }
<span class="nc" id="L86">        LiftRequest request = LiftRequest.carCall(carCall.destinationFloor());</span>
<span class="nc" id="L87">        request.transitionTo(RequestState.QUEUED);</span>
<span class="nc" id="L88">        trackRequest(request);</span>
<span class="nc" id="L89">    }</span>

    /**
     * Adds a hall call (request from a floor to go up or down).
     *
     * @param hallCall the hall call to add
     */
    public void addHallCall(HallCall hallCall) {
<span class="nc bnc" id="L97" title="All 2 branches missed.">        if (outOfService) {</span>
<span class="nc" id="L98">            return;</span>
        }
<span class="nc" id="L100">        LiftRequest request = LiftRequest.hallCall(hallCall.floor(), hallCall.direction());</span>
<span class="nc" id="L101">        request.transitionTo(RequestState.QUEUED);</span>
<span class="nc" id="L102">        trackRequest(request);</span>
<span class="nc" id="L103">    }</span>

    /**
     * Adds a lift request directly.
     *
     * @param request the lift request to add
     */
    public void addRequest(LiftRequest request) {
<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (outOfService) {</span>
<span class="nc" id="L112">            return;</span>
        }
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (request.getState() == RequestState.CREATED) {</span>
<span class="nc" id="L115">            request.transitionTo(RequestState.QUEUED);</span>
        }
<span class="nc" id="L117">        trackRequest(request);</span>
<span class="nc" id="L118">    }</span>

    /**
     * Cancels a lift request by its ID.
     * The request will be transitioned to CANCELLED state and removed from the queue.
     * This method is safe to call for requests in any state.
     *
     * @param requestId the ID of the request to cancel
     * @return true if the request was found and cancelled, false if not found or already terminal
     */
    public boolean cancelRequest(long requestId) {
<span class="nc" id="L129">        LiftRequest request = requestsById.get(requestId);</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (request == null) {</span>
<span class="nc" id="L131">            return false;</span>
        }

        // If already terminal (completed or cancelled), nothing to do.
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (request.isTerminal()) {</span>
<span class="nc" id="L136">            return false;</span>
        }

        // Transition to cancelled state.
<span class="nc" id="L140">        request.transitionTo(RequestState.CANCELLED);</span>

<span class="nc" id="L142">        archiveRequest(request);</span>

<span class="nc" id="L144">        return true;</span>
    }

    /**
     * Completes all requests for the given floor.
     * This is called when the lift arrives at a floor and opens doors.
     * Transitions requests from SERVING to COMPLETED.
     *
     * @param floor the floor to complete requests for
     */
    private void completeRequestsForFloor(int floor) {
<span class="nc" id="L155">        Set&lt;LiftRequest&gt; requestsToComplete = activeRequests.stream()</span>
<span class="nc bnc" id="L156" title="All 4 branches missed.">                .filter(request -&gt; !request.isTerminal() &amp;&amp; request.getTargetFloor() == floor)</span>
<span class="nc" id="L157">                .collect(Collectors.toSet());</span>

<span class="nc bnc" id="L159" title="All 2 branches missed.">        for (LiftRequest request : requestsToComplete) {</span>
<span class="nc" id="L160">            request.completeRequest();</span>
<span class="nc" id="L161">        }</span>

        // Remove completed requests.
<span class="nc bnc" id="L164" title="All 2 branches missed.">        for (LiftRequest request : requestsToComplete) {</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">            if (request.isTerminal()) {</span>
<span class="nc" id="L166">                archiveRequest(request);</span>
            }
<span class="nc" id="L168">        }</span>
<span class="nc" id="L169">    }</span>

    /**
     * Checks if there is any active request for the given floor.
     *
     * @param floor the floor to check
     * @return true if there is an active request for this floor
     */
    private boolean hasRequestForFloor(int floor) {
<span class="nc" id="L178">        return activeRequests.stream()</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">                .filter(request -&gt; !request.isTerminal())</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                .anyMatch(request -&gt; request.getTargetFloor() == floor);</span>
    }

    /**
     * Gets all active (non-terminal) requests.
     *
     * @return set of active requests
     */
    private Set&lt;LiftRequest&gt; getActiveRequests() {
<span class="nc" id="L189">        return Collections.unmodifiableSet(activeRequests);</span>
    }

    /**
     * Finds the nearest floor with a pending request.
     * Assigns requests to the lift when they are selected for service.
     *
     * @param currentFloor the current floor of the lift
     * @return the nearest requested floor, or empty if no requests
     */
    private Optional&lt;Integer&gt; findNearestRequestedFloor(int currentFloor) {
<span class="nc" id="L200">        Set&lt;Integer&gt; requestedFloors = new TreeSet&lt;&gt;();</span>

        // Collect all requested floors from active requests.
<span class="nc bnc" id="L203" title="All 2 branches missed.">        for (LiftRequest request : getActiveRequests()) {</span>
<span class="nc" id="L204">            requestedFloors.add(request.getTargetFloor());</span>
<span class="nc" id="L205">        }</span>

        // Find the nearest one.
<span class="nc" id="L208">        return requestedFloors.stream()</span>
<span class="nc" id="L209">                .min((f1, f2) -&gt; {</span>
<span class="nc" id="L210">                    int dist1 = Math.abs(f1 - currentFloor);</span>
<span class="nc" id="L211">                    int dist2 = Math.abs(f2 - currentFloor);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">                    if (dist1 != dist2) {</span>
<span class="nc" id="L213">                        return Integer.compare(dist1, dist2);</span>
                    }
<span class="nc" id="L215">                    return Integer.compare(f1, f2);</span>
                });
    }

    /**
     * Assigns requests for the target floor to the lift.
     * Transitions requests from QUEUED to ASSIGNED.
     *
     * @param targetFloor the floor being targeted
     */
    private void assignRequestsForFloor(int targetFloor) {
<span class="nc" id="L226">        getActiveRequests().stream()</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">                .filter(request -&gt; request.getTargetFloor() == targetFloor)</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">                .filter(request -&gt; request.getState() == RequestState.QUEUED)</span>
<span class="nc" id="L229">                .forEach(request -&gt; request.transitionTo(RequestState.ASSIGNED));</span>
<span class="nc" id="L230">    }</span>

    /**
     * Marks assigned requests as being served.
     * Transitions requests from ASSIGNED to SERVING.
     *
     * @param targetFloor the floor being served
     */
    private void serveRequestsForFloor(int targetFloor) {
<span class="nc" id="L239">        getActiveRequests().stream()</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">                .filter(request -&gt; request.getTargetFloor() == targetFloor)</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                .filter(request -&gt; request.getState() == RequestState.ASSIGNED)</span>
<span class="nc" id="L242">                .forEach(request -&gt; request.transitionTo(RequestState.SERVING));</span>
<span class="nc" id="L243">    }</span>

    private void resetIdleTracking() {
<span class="nc" id="L246">        idleStartTick = null;</span>
<span class="nc" id="L247">        parkingInProgress = false;</span>
<span class="nc" id="L248">    }</span>

    private boolean shouldTrackIdle(LiftState currentState) {
<span class="nc bnc" id="L251" title="All 4 branches missed.">        return currentState.getStatus() == LiftStatus.IDLE &amp;&amp; currentState.getDoorState() == DoorState.CLOSED;</span>
    }

    private Action moveTowardHome(int currentFloor) {
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (currentFloor &lt; homeFloor) {</span>
<span class="nc" id="L256">            return Action.MOVE_UP;</span>
        }
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (currentFloor &gt; homeFloor) {</span>
<span class="nc" id="L259">            return Action.MOVE_DOWN;</span>
        }
<span class="nc" id="L261">        return Action.IDLE;</span>
    }

    @Override
    public Action decideNextAction(LiftState currentState, long currentTick) {
<span class="nc" id="L266">        int currentFloor = currentState.getFloor();</span>
<span class="nc" id="L267">        DoorState doorState = currentState.getDoorState();</span>
<span class="nc" id="L268">        LiftStatus currentStatus = currentState.getStatus();</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        boolean hasActiveRequests = !getActiveRequests().isEmpty();</span>

<span class="nc bnc" id="L271" title="All 4 branches missed.">        if (currentStatus == LiftStatus.OUT_OF_SERVICE || outOfService) {</span>
<span class="nc" id="L272">            return Action.IDLE;</span>
        }

<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (hasActiveRequests) {</span>
<span class="nc" id="L276">            resetIdleTracking();</span>
        }

        // Allow door transitions to complete before evaluating movement.
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (currentStatus == LiftStatus.DOORS_OPENING) {</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">            if (hasRequestForFloor(currentFloor)) {</span>
<span class="nc" id="L282">                serveRequestsForFloor(currentFloor);</span>
<span class="nc" id="L283">                completeRequestsForFloor(currentFloor);</span>
            }
<span class="nc" id="L285">            return Action.IDLE;</span>
        }

<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (currentStatus == LiftStatus.DOORS_CLOSING) {</span>
            // Check if a new request arrived for current floor while doors closing.
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (hasRequestForFloor(currentFloor)) {</span>
                // Attempt to reopen doors (will succeed only if within reopen window).
<span class="nc" id="L292">                return Action.OPEN_DOOR;</span>
            }
<span class="nc" id="L294">            return Action.IDLE;</span>
        }

        // If doors are open, let the engine manage the dwell/close cycle.
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (doorState == DoorState.OPEN) {</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">            if (hasRequestForFloor(currentFloor)) {</span>
<span class="nc" id="L300">                completeRequestsForFloor(currentFloor);</span>
            }
<span class="nc" id="L302">            return Action.IDLE;</span>
        }

        // If at a requested floor, stop first if moving, then open doors.
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (hasRequestForFloor(currentFloor)) {</span>
<span class="nc bnc" id="L307" title="All 4 branches missed.">            if (currentStatus == LiftStatus.MOVING_UP || currentStatus == LiftStatus.MOVING_DOWN) {</span>
<span class="nc" id="L308">                assignRequestsForFloor(currentFloor);</span>
<span class="nc" id="L309">                serveRequestsForFloor(currentFloor);</span>
<span class="nc" id="L310">                return Action.IDLE;</span>
            }
<span class="nc bnc" id="L312" title="All 2 branches missed.">            if (currentStatus == LiftStatus.DOORS_OPENING) {</span>
<span class="nc" id="L313">                completeRequestsForFloor(currentFloor);</span>
<span class="nc" id="L314">                return Action.IDLE;</span>
            }
<span class="nc" id="L316">            assignRequestsForFloor(currentFloor);</span>
<span class="nc" id="L317">            serveRequestsForFloor(currentFloor);</span>
<span class="nc" id="L318">            return Action.OPEN_DOOR;</span>
        }

        // Find nearest requested floor and move towards it.
<span class="nc" id="L322">        Optional&lt;Integer&gt; nearestFloor = findNearestRequestedFloor(currentFloor);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (nearestFloor.isPresent()) {</span>
<span class="nc" id="L324">            int targetFloor = nearestFloor.get();</span>
<span class="nc" id="L325">            assignRequestsForFloor(targetFloor);</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">            if (currentStatus == LiftStatus.MOVING_UP &amp;&amp; targetFloor &lt; currentFloor) {</span>
<span class="nc" id="L327">                return Action.IDLE;</span>
            }
<span class="nc bnc" id="L329" title="All 4 branches missed.">            if (currentStatus == LiftStatus.MOVING_DOWN &amp;&amp; targetFloor &gt; currentFloor) {</span>
<span class="nc" id="L330">                return Action.IDLE;</span>
            }
<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (currentFloor &lt; targetFloor) {</span>
<span class="nc" id="L333">                return Action.MOVE_UP;</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">            } else if (currentFloor &gt; targetFloor) {</span>
<span class="nc" id="L335">                return Action.MOVE_DOWN;</span>
            }
        }

<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (!hasActiveRequests) {</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">            if (parkingInProgress) {</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">                if (currentFloor == homeFloor) {</span>
<span class="nc" id="L342">                    parkingInProgress = false;</span>
<span class="nc" id="L343">                    idleStartTick = currentTick;</span>
<span class="nc" id="L344">                    return Action.IDLE;</span>
                }
<span class="nc" id="L346">                return moveTowardHome(currentFloor);</span>
            }

<span class="nc bnc" id="L349" title="All 2 branches missed.">            if (shouldTrackIdle(currentState)) {</span>
<span class="nc" id="L350">                Long trackedIdleStartTick = idleStartTick;</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                if (trackedIdleStartTick == null) {</span>
<span class="nc" id="L352">                    trackedIdleStartTick = currentTick;</span>
<span class="nc" id="L353">                    idleStartTick = currentTick;</span>
                }
<span class="nc" id="L355">                long idleTicks = currentTick - trackedIdleStartTick;</span>
<span class="nc bnc" id="L356" title="All 6 branches missed.">                if (idleTicks &gt;= idleTimeoutTicks &amp;&amp; currentFloor != homeFloor</span>
                        &amp;&amp; idleParkingMode == IdleParkingMode.PARK_TO_HOME_FLOOR) {
<span class="nc" id="L358">                    parkingInProgress = true;</span>
<span class="nc" id="L359">                    return moveTowardHome(currentFloor);</span>
                }
<span class="nc" id="L361">            } else {</span>
<span class="nc" id="L362">                idleStartTick = null;</span>
            }
        }

        // No requests, stay idle.
<span class="nc" id="L367">        return Action.IDLE;</span>
    }

    /**
     * Takes the lift out of service by cancelling all active requests.
     * This method cancels all non-terminal requests (QUEUED, ASSIGNED, SERVING).
     * After calling this method, the lift should be transitioned to OUT_OF_SERVICE
     * state via the SimulationEngine.
     *
     * The lift will:
     * - Stop at the nearest floor if moving
     * - Open and close doors if at a floor
     * - Cancel all pending requests
     */
    public void takeOutOfService() {
<span class="nc" id="L382">        outOfService = true;</span>
        // Cancel all active (non-terminal) requests.
<span class="nc" id="L384">        Set&lt;LiftRequest&gt; activeRequests = new HashSet&lt;&gt;(getActiveRequests());</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">        for (LiftRequest request : activeRequests) {</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">            if (!request.isTerminal()) {</span>
<span class="nc" id="L387">                request.transitionTo(RequestState.CANCELLED);</span>
<span class="nc" id="L388">                archiveRequest(request);</span>
            }
<span class="nc" id="L390">        }</span>

        // Reset idle tracking and parking state.
<span class="nc" id="L393">        resetIdleTracking();</span>
<span class="nc" id="L394">    }</span>

    /**
     * Prepares the lift to return to service.
     * After calling this method, the lift should be transitioned from OUT_OF_SERVICE
     * to IDLE state via the SimulationEngine.
     */
    public void returnToService() {
<span class="nc" id="L402">        outOfService = false;</span>
        // Reset idle tracking when returning to service.
<span class="nc" id="L404">        resetIdleTracking();</span>
<span class="nc" id="L405">    }</span>

    /**
     * Gets all requests (for testing purposes).
     *
     * @return a copy of all requests
     */
    public Set&lt;LiftRequest&gt; getRequests() {
<span class="nc" id="L413">        return new HashSet&lt;&gt;(activeRequests);</span>
    }

    private void archiveRequest(LiftRequest request) {
<span class="nc" id="L417">        activeRequests.remove(request);</span>
<span class="nc" id="L418">        completedRequests.add(request);</span>
<span class="nc" id="L419">        requestsById.remove(request.getId());</span>
<span class="nc" id="L420">    }</span>

    private void trackRequest(LiftRequest request) {
<span class="nc" id="L423">        activeRequests.add(request);</span>
<span class="nc" id="L424">        requestsById.put(request.getId(), request);</span>
<span class="nc" id="L425">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>